---
title: "Extending the SummarizedExperiment class"
author: Aaron Lun
date: "Revised: 28 April, 2018"
output:
  BiocStyle::html_document:
    toc: true
vignette: >
  %\VignetteIndexEntry{Extensions}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r, echo=FALSE, results="hide"}
knitr::opts_chunk$set(error=FALSE, warning=FALSE, message=FALSE)
```

```{r, echo=FALSE}
library(SummarizedExperiment)
library(testthat)
```

# Motivation

A large number of Bioconductor packages contain extensions of the standard `SummarizedExperiment` class from the `r Biocpkg("SummarizedExperiment")` package.
This allows developers to take advantage of the power of the `SummarizedExperiment` representation for synchronising data and metadata, 
while still accommodating specialized data structures for particular scientific applications.
This document is intended to provide a developer-level "best practices" reference for the creation of these derived classes.

# Creating a derived class

To demonstrate, we will consider the derivation of an example class that requires some specialized slots.
First, we consider 1D data structures:

- `rowVec`: 1:1 mapping from each value to a row of the `SummarizedExperiment`.
- `colVec`: 1:1 mapping from each value to a column of the `SummarizedExperiment`.

Any 1D structure can be used if it supports `length`, `c`, `[` and `[<-`.
For simplicity, we will use integer vectors for the `*.vec` slots.

We also consider some 2D data structures: 

- `rowToRowMat`: 1:1 mapping from each row to a row of the `SummarizedExperiment`.
- `colToColMat`: 1:1 mapping from each column to a column of the `SummarizedExperiment`.
- `rowToColMat`: 1:1 mapping from each row to a column of the `SummarizedExperiment`.
- `colToRowMat`: 1:1 mapping from each column to a row of the `SummarizedExperiment`.

Any 2D structure can be used if it supports `nrow`, `ncol`, `cbind`, `rbind`, `[` and `[<-`.
For simplicity, we will use (numeric) matrices for the `*.mat` slots.

Definition of the class is achieved using the `setClass` function from the _methods_ package, as conventionally done for all S4 classes.
We will use Roxygen's `#'` tags to trigger the generation of import/export statements in the `NAMESPACE`.

```{r}
#' @export
#' @import methods
#' @importClassesFrom SummarizedExperiment SummarizedExperiment
.ExampleClass <- setClass("ExampleClass",
    slots= representation(
        rowVec="integer",
        colVec="integer",
        rowToRowMat="matrix",
        colToColMat="matrix",
        rowToColMat="matrix",
        colToRowMat="matrix"
    ),
    contains="SummarizedExperiment")
```

# Defining the constructor

The constructor should provide some arguments for setting the new slots in the derived class definition.
The default values should be set such that calling the constructor without any arguments returns a valid `ExampleClass` object.
We use `...` to pass further arguments to the `SummarizedExperiment` constructor, which allows us to avoid re-specifying all its arguments.
Of course, it is straightforward to specify individual arguments to be passed to the `SummarizedExperiment` constructor if necessary.

```{r}
#' @export
#' @importFrom SummarizedExperiment SummarizedExperiment
ExampleClass <- function(
        rowVec=integer(0), 
        colVec=integer(0),
        rowToRowMat=matrix(0,0,0),
        colToColMat=matrix(0,0,0),
        rowToColMat=matrix(0,0,0),
        colToRowMat=matrix(0,0,0),
        ...) {
    
    se <- SummarizedExperiment(...)
    .ExampleClass(se, rowVec=rowVec, colVec=colVec,
        rowToRowMat=rowToRowMat, colToColMat=colToColMat, 
        rowToColMat=rowToColMat, colToRowMat=colToRowMat)
}
```

Let's test out this constructor by creating an instance of `ExampleClass` that has 10 rows and 7 columns:

```{r}
RV <- 1:10
CV <- sample(50, 7)
RRM <- matrix(runif(30), nrow=10)
CCM <- matrix(rnorm(14), ncol=7)
RCM <- matrix(runif(21), nrow=7)
CRM <- matrix(rnorm(20), ncol=10)

thing <- ExampleClass(rowVec=RV, colVec=CV,
    rowToRowMat=RRM, colToColMat=CCM,
    rowToColMat=RCM, colToRowMat=CRM,
    assays=list(counts=matrix(rnorm(70), nrow=10)),
    colData=DataFrame(whee=LETTERS[1:7]),
    rowData=DataFrame(yay=letters[1:10]))
```

We will also add some row and column names, which will come in handy later.

```{r}
rownames(thing) <- paste0("FEATURE_", seq_len(nrow(thing)))
colnames(thing) <- paste0("SAMPLE_", seq_len(ncol(thing)))
```

# Creating getter methods

## For 1D data structures

We define some getter methods for the custom slots containing the 1D structures.
This usually requires the creation of new generics if they are not already available, e.g., in `r Biocpkg("BiocGenerics")` or `r Biocpkg("S4Vectors")`^[If you have an idea for a generally applicable generic that is not yet available, please contact the Bioconductor core team.].
The `...` in the generic function definition means that custom arguments can be provided for specific methods.

```{r}
#' @export
setGeneric("rowVec", function(x, ...) standardGeneric("rowVec"))
#' @export
setGeneric("colVec", function(x, ...) standardGeneric("colVec"))
```

We then define the class-specific methods for these generics.
Note the `withDimnames=TRUE` argument, which enforces consistency between the names of the extracted object and the original `SummarizedExperiment`.
It is possible to turn this off for greater efficiency, e.g., for internal usage where names are not necessary.

```{r}
#' @export
setMethod("rowVec", "ExampleClass", function(x, withDimnames=TRUE) {
    out <- x@rowVec
    if (withDimnames) 
        names(out) <- rownames(x)
    out
})

#' @export
setMethod("colVec", "ExampleClass", function(x, withDimnames=TRUE) {
    out <- x@colVec
    if (withDimnames) 
        names(out) <- colnames(x)
    out
})
```

We check that the methods work:

```{r}
rowVec(thing)
colVec(thing)
```

We test these methods more formally using the `expect_*` functions from the `r CRANpkg("testthat")` package.
These calls will raise an error if the output is not as expected, which can be used to construct unit tests for the `tests/` subdirectory of your package.

```{r}
expect_identical(names(rowVec(thing)), rownames(thing))
expect_identical(rowVec(thing, withDimnames=FALSE), RV)

expect_identical(names(colVec(thing)), colnames(thing))
expect_identical(colVec(thing, withDimnames=FALSE), CV)
```

## For 2D data structures

We repeat this process for the 2D structures.

```{r}
#' @export
setGeneric("rowToRowMat", function(x, ...) standardGeneric("rowToRowMat"))
#' @export
setGeneric("colToColMat", function(x, ...) standardGeneric("colToColMat"))
#' @export
setGeneric("rowToColMat", function(x, ...) standardGeneric("rowToColMat"))
#' @export
setGeneric("colToRowMat", function(x, ...) standardGeneric("colToRowMat"))
```

Again, we define class-specific methods for these generics.

```{r}
#' @export
setMethod("rowToRowMat", "ExampleClass", function(x, withDimnames=TRUE) {
    out <- x@rowToRowMat
    if (withDimnames) 
        rownames(out) <- rownames(x)
    out
})

#' @export
setMethod("colToColMat", "ExampleClass", function(x, withDimnames=TRUE) {
    out <- x@colToColMat
    if (withDimnames) 
        colnames(out) <- colnames(x)
    out
})

#' @export
setMethod("rowToColMat", "ExampleClass", function(x, withDimnames=TRUE) {
    out <- x@rowToColMat
    if (withDimnames) 
        rownames(out) <- colnames(x)
    out
})

#' @export
setMethod("colToRowMat", "ExampleClass", function(x, withDimnames=TRUE) {
    out <- x@colToRowMat
    if (withDimnames) 
        colnames(out) <- rownames(x)
    out
})
```

Checking that the methods work:

```{r}
head(rowToRowMat(thing))
head(colToColMat(thing))
head(rowToColMat(thing))
head(colToRowMat(thing))
```


Testing them with `r CRANpkg("testthat")` functions:

```{r}
expect_identical(rowToRowMat(thing, withDimnames=FALSE), RRM)
expect_identical(rownames(rowToRowMat(thing)), rownames(thing))

expect_identical(colToColMat(thing, withDimnames=FALSE), CCM)
expect_identical(colnames(colToColMat(thing)), colnames(thing))

expect_identical(rowToColMat(thing, withDimnames=FALSE), RCM)
expect_identical(rownames(rowToColMat(thing)), colnames(thing))

expect_identical(colToRowMat(thing, withDimnames=FALSE), CRM)
expect_identical(colnames(colToRowMat(thing)), rownames(thing))
```

## For `SummarizedExperiment` slots

Obviously, we can use the getter methods defined in `r Biocpkg("SummarizedExperiment")` to retrieve data from slots in the base class:

```{r}
assayNames(thing)
colData(thing)
rowData(thing)
```

These should generally not require any re-defining for a derived class.
However, if it is necessary, the methods should use `callNextMethod` internally.
This will call the method for the base `SummarizedExperiment` class, the output of which can be modified as required.

```{r}
#' @export
#' @importMethodsFrom SummarizedExperiment rowData
setMethod("rowData", "ExampleClass", function(x, ...) {
    out <- callNextMethod()
    
    # Do something extra here.
    out$extra <- runif(nrow(out))

    # Returning the rowData object.
    out
})
```

The function now adds the `extra` field to the `rowData`, as instructed.

```{r}
colnames(rowData(thing))
```    

Or more formally, in our unit testing framework:

```{r}
expect_true("extra" %in% colnames(rowData(thing)))
```

# Defining the validity method

We want to be notified (and an error to be thrown) if the new slots are filled with inappropriate values.
This is done by defining a validity function using `setValidity2` from the `r Biocpkg("S4Vectors")` package^[This allows us to turn off the validity checks in internal functions where intermediate objects may not be valid within the scope of the function.].
Returning a string indicates that there is a problem with the validity of the `ExampleClass` instance.

```{r}
setValidity2("ExampleClass", function(object) {
    NR <- NROW(object)
    NC <- NCOL(object)
    msg <- NULL

    # 1D
    if (length(rowVec(object, withDimnames=FALSE)) != NR) {
        msg <- c(msg, "'rowVec' should have length equal to the number of rows")
    }
    if (length(colVec(object, withDimnames=FALSE)) != NC) {
        msg <- c(msg, "'colVec' should have length equal to the number of columns")
    }

    # 2D
    if (NROW(rowToRowMat(object, withDimnames=FALSE)) != NR) {
        msg <- c(msg, "'nrow(rowToRowMat)' should be equal to the number of rows")
    }
    if (NCOL(colToColMat(object, withDimnames=FALSE)) != NC) {
        msg <- c(msg, "'ncol(colToColMat)' should be equal to the number of columns")
    }
    if (NROW(rowToColMat(object, withDimnames=FALSE)) != NC) {
        msg <- c(msg, "'nrow(rowToColMat)' should be equal to the number of columns")
    }
    if (NCOL(colToRowMat(object, withDimnames=FALSE)) != NR) {
        msg <- c(msg, "'ncol(colToRowMat)' should be equal to the number of rows")
    }

    if (length(msg)) {
        return(msg)
    }
    return(TRUE)
})
```

Some notes about this function:

- We use the `NCOL` and `NROW` methods from `r Biocpkg("BiocGenerics")` as these provide support for various Bioconductor objects.
- We use the getter functions to retreive the slot values rather than using `@`.
There were good reasons for this, but I have forgotten them.
- We also set `withDimnames=FALSE` in our getter calls, as consistent naming is not necessary for internal functions.

A useful set of unit tests involves checking that the default constructors (internal and exported) yield valid objects, along with the `thing` object we constructed earlier:

```{r}
expect_true(validObject(.ExampleClass())) # internal
expect_true(validObject(ExampleClass())) # exported
expect_true(validObject(thing))
```

# Creating a `show` method

The default `show` method will only display the `SummarizedExperiment` slots.
We can augment it to display some relevant aspects of the custom slots.
This is done by calling the base `show` method before printing additional fields as necessary.

```{r}
#' @export
#' @importMethodsFrom SummarizedExperiment show
setMethod("show", "ExampleClass", function(object) {
    callNextMethod()
    cat(
        "rowToRowMat has ", ncol(rowToRowMat(object)), " columns\n",
        "colToColMat has ", nrow(colToColMat(object)), " rows\n",
        "rowToColMat has ", ncol(rowToRowMat(object)), " columns\n",
        "colToRowMat has ", ncol(rowToRowMat(object)), " rows\n",
        sep=""
    )
})
```

Printing the object will now add the extra information about the custom slots.

```{r}
thing
```

# Creating setter methods

## For 1D data structures

We define some setter methods for the custom slots containing the 1D structures.
Again, this usually requires the creation of new generics.

```{r}
#' @export
setGeneric("rowVec<-", function(x, ..., value) standardGeneric("rowVec<-"))
#' @export
setGeneric("colVec<-", function(x, ..., value) standardGeneric("colVec<-"))
```

We define the class-specific methods for these generics.
Note that use of `validObject` to ensure that the assigned input is still valid.

```{r}
#' @export
setReplaceMethod("rowVec", "ExampleClass", function(x, value) {
    x@rowVec <- value
    validObject(x)
    x
})

#' @export
setReplaceMethod("colVec", "ExampleClass", function(x, value) {
    x@colVec <- value
    validObject(x)
    x
})
```

We test these methods out, using the `test_equivalent` function to ignore names for simplicity.

```{r}
rowVec(thing) <- 0:9
expect_equivalent(rowVec(thing), 0:9)

colVec(thing) <- 7:1
expect_equivalent(colVec(thing), 7:1)
```

## For 2D data structures

We repeat this process for the 2D structures.

```{r}
#' @export
setGeneric("rowToRowMat<-", function(x, ..., value) standardGeneric("rowToRowMat<-"))
#' @export
setGeneric("colToColMat<-", function(x, ..., value) standardGeneric("colToColMat<-"))
#' @export
setGeneric("rowToColMat<-", function(x, ..., value) standardGeneric("rowToColMat<-"))
#' @export
setGeneric("colToRowMat<-", function(x, ..., value) standardGeneric("colToRowMat<-"))
```

Again, we define class-specific methods for these generics.

```{r}
#' @export
setReplaceMethod("rowToRowMat", "ExampleClass", function(x, value) {
    x@rowToRowMat <- value
    validObject(x)
    x
})

#' @export
setReplaceMethod("colToColMat", "ExampleClass", function(x, value) {
    x@colToColMat <- value
    validObject(x)
    x
})

#' @export
setReplaceMethod("rowToColMat", "ExampleClass", function(x, value) {
    x@rowToColMat <- value
    validObject(x)
    x
})

#' @export
setReplaceMethod("colToRowMat", "ExampleClass", function(x, value) {
    x@colToRowMat <- value
    validObject(x)
    x
})
```

Testing them out:

```{r}
old <- rowToRowMat(thing)
rowToRowMat(thing) <- -old
expect_equivalent(rowToRowMat(thing), -old)

old <- colToColMat(thing)
colToColMat(thing) <- 2 * old
expect_equivalent(colToColMat(thing), 2 * old)

old <- rowToColMat(thing)
rowToColMat(thing) <- old + 1
expect_equivalent(rowToColMat(thing), old + 1)

old <- colToRowMat(thing) 
colToRowMat(thing) <- old / 10
expect_equivalent(colToRowMat(thing), old / 10)
```

## For `SummarizedExperiment` slots

Again, we can use the setter methods defined in `r Biocpkg("SummarizedExperiment")` to modify slots in the base class:

```{r}
colData(thing)$stuff <- sample(100, ncol(thing))
rowData(thing)$blah <- sample(100, nrow(thing))
```

These should generally not require any re-defining.
However, if it is necessary, the methods should use `callNextMethod` internally:

```{r}
#' @export
#' @importMethodsFrom SummarizedExperiment "rowData<-"
setReplaceMethod("rowData", "ExampleClass", function(x, ..., value) {
    y <- callNextMethod() # returns a modified ExampleClass
    
    # Do something extra here.
    cat("hi!\n")

    y
})
```

And indeed:

```{r}
rowData(thing)$yay <- 1
```

Or more formally:

```{r}
expect_output(rowData(thing) <- 1, "hi")
```

## Other types of modifying functions 

Imagine that we want to write a function that returns a modified `ExampleClass`, e.g., where the signs of the `*.vec` fields are reversed.
For example, we will pretend that we want to write a `normalize` function, using the generic from `r Biocpkg("BiocGenerics")`.

```{r}
#' @export
#' @importFrom BiocGenerics normalize
setMethod("normalize", "ExampleClass", function(object) {
    # do something exciting, i.e., flip the signs
    new.row <- -rowVec(object, withDimnames=FALSE) 
    new.col <- -colVec(object, withDimnames=FALSE)
    BiocGenerics:::replaceSlots(object, rowVec=new.row, 
        colVec=new.col, check=FALSE)
})
```

We use `BiocGenerics:::replaceSlots` instead of the setter methods that we defined above.
This is because our setters perform validity checks that are unnecessary if we know that the modification cannot alter the validity of the object.
The `replaceSlots` function allows us to skip these validity checks (`check=FALSE`) for greater efficiency.

```{r}
modified <- normalize(thing)
rowVec(modified)
colVec(modified)
```

In our unit testing framework:

```{r}
expect_equal(rowVec(modified), -rowVec(thing))
expect_equal(colVec(modified), -colVec(thing))
```

# Enabling subsetting operations

## Getting a subset

A key strength of the `SummarizedExperiment` class is that subsetting is synchronized across the various (meta)data fields.
This avoids book-keeping errors and guarantees consistency throughout an interactive analysis session.
We need to ensure that the values in our custom slots are also subsetted.

```{r}
#' @export
setMethod("[", "ExampleClass", function(x, i, j, drop=TRUE) {
    rv <- rowVec(x, withDimnames=FALSE)
    cv <- colVec(x, withDimnames=FALSE)
    rrm <- rowToRowMat(x, withDimnames=FALSE)
    ccm <- colToColMat(x, withDimnames=FALSE)
    rcm <- rowToColMat(x, withDimnames=FALSE)
    crm <- colToRowMat(x, withDimnames=FALSE)

    if (!missing(i)) {
        if (is.character(i)) {
            fmt <- paste0("<", class(x), ">[i,] index out of bounds: %s")
            i <- SummarizedExperiment:::.SummarizedExperiment.charbound(i, rownames(x), fmt)
        }
        i <- as.vector(i)
        rv <- rv[i]
        rrm <- rrm[i,,drop=FALSE]
        crm <- crm[,i,drop=FALSE]
    }

    if (!missing(j)) {
        if (is.character(j)) {
            fmt <- paste0("<", class(x), ">[,j] index out of bounds: %s")
            j <- SummarizedExperiment:::.SummarizedExperiment.charbound(j, colnames(x), fmt)
        }
        j <- as.vector(j)
        cv <- cv[j]
        ccm <- ccm[,j,drop=FALSE]
        rcm <- rcm[j,,drop=FALSE]
    }

    out <- callNextMethod()
    BiocGenerics:::replaceSlots(out, rowVec=rv, colVec=cv,
        rowToRowMat=rrm, colToColMat=ccm, 
        rowToColMat=rcm, colToRowMat=crm, check=FALSE)
})
```

Note the special code for handling character indices, and the use of `callNextMethod` to subset the base `SummarizedExperiment` slots.

We can check that this is working properly:

```{r}
(subbyrow <- thing[1:5,])
(subbycol <- thing[,1:2])
```

Or more formally:

```{r}
expect_identical(rowVec(subbyrow), rowVec(thing)[1:5])
expect_identical(rowToRowMat(subbyrow), rowToRowMat(thing)[1:5,])
expect_identical(colToRowMat(subbyrow), colToRowMat(thing)[,1:5])
expect_identical(colVec(subbyrow), colVec(thing)) # columns unaffected...
expect_identical(colToColMat(subbyrow), colToColMat(thing))
expect_identical(rowToColMat(subbyrow), rowToColMat(thing))

expect_identical(colVec(subbycol), colVec(thing)[1:2])
expect_identical(colToColMat(subbycol), colToColMat(thing)[,1:2])
expect_identical(rowToColMat(subbycol), rowToColMat(thing)[1:2,])
expect_identical(rowVec(subbycol), rowVec(thing)) # rows unaffected...
expect_identical(rowToRowMat(subbycol), rowToRowMat(thing))
expect_identical(colToRowMat(subbycol), colToRowMat(thing))
```

## Assigning a subset

Subset assignment can be similarly performed, though the signature needs to be specified so that the replacement value is of the same class.
This is generally necessary for sensible replacement of the custom slots.

```{r}
#' @export
setReplaceMethod("[", c("ExampleClass", "ANY", "ANY", "ExampleClass"),
        function(x, i, j, ..., value) {
    rv <- rowVec(x, withDimnames=FALSE)
    cv <- colVec(x, withDimnames=FALSE)
    rrm <- rowToRowMat(x, withDimnames=FALSE)
    ccm <- colToColMat(x, withDimnames=FALSE)
    rcm <- rowToColMat(x, withDimnames=FALSE)
    crm <- colToRowMat(x, withDimnames=FALSE)

    if (!missing(i)) {
        if (is.character(i)) {
            fmt <- paste0("<", class(x), ">[i,] index out of bounds: %s")
            i <- SummarizedExperiment:::.SummarizedExperiment.charbound(i, rownames(x), fmt)
        }
        i <- as.vector(i)
        rv[i] <- rowVec(value, withDimnames=FALSE)
        rrm[i,] <- rowToRowMat(value, withDimnames=FALSE)
        crm[,i] <- colToRowMat(value, withDimnames=FALSE)
    }

    if (!missing(j)) {
        if (is.character(j)) {
            fmt <- paste0("<", class(x), ">[,j] index out of bounds: %s")
            j <- SummarizedExperiment:::.SummarizedExperiment.charbound(j, colnames(x), fmt)
        }
        j <- as.vector(j)
        cv[j] <- colVec(value, withDimnames=FALSE)
        ccm[,j] <- colToColMat(value, withDimnames=FALSE)
        rcm[j,] <- rowToColMat(value, withDimnames=FALSE)
    }

    out <- callNextMethod()
    BiocGenerics:::replaceSlots(out, rowVec=rv, colVec=cv,
        rowToRowMat=rrm, colToColMat=ccm, 
        rowToColMat=rcm, colToRowMat=crm, check=FALSE)
})
```

We can check that this is working properly:

```{r}
modified <- thing
modified[1:5,1:2] <- thing[5:1,2:1]
rowVec(modified)
colVec(modified)
```

Or more formally:

```{r}
rperm <- c(5:1, 6:nrow(thing))
cperm <- c(2:1, 3:ncol(thing))
expect_identical(rowVec(modified), rowVec(thing)[rperm])
expect_identical(rowToRowMat(modified), rowToRowMat(thing)[rperm,])
expect_identical(colToRowMat(modified), colToRowMat(thing)[,rperm])
expect_identical(colVec(modified), colVec(thing)[cperm])
expect_identical(colToColMat(modified), colToColMat(thing)[,cperm])
expect_identical(rowToColMat(modified), rowToColMat(thing)[cperm,])
```

# Defining combining methods

## By row

We need to define a `rbind` method for our custom class.
This is done by combining the custom per-row slots across class instances.

```{r}
#' @export
setMethod("rbind", "ExampleClass", function(..., deparse.level=1) {
    args <- list(...)
    all.rv <- lapply(args, rowVec, withDimnames=FALSE)
    all.rrm <- lapply(args, rowToRowMat, withDimnames=FALSE)
    all.crm <- lapply(args, colToRowMat, withDimnames=FALSE)

    all.rv <- do.call(c, all.rv)
    all.rrm <- do.call(rbind, all.rrm)
    all.crm <- do.call(cbind, all.crm)

    # Checks for identical column state.
    ref <- args[[1]]
    ref.cv <- colVec(ref, withDimnames=FALSE)
    ref.ccm <- colToColMat(ref, withDimnames=FALSE)
    ref.rcm <- rowToColMat(ref, withDimnames=FALSE)
    for (x in args[-1]) {
        if (!identical(ref.cv, colVec(x, withDimnames=FALSE)) 
            || !identical(ref.ccm, colToColMat(x, withDimnames=FALSE))
            || !identical(ref.rcm, rowToColMat(x, withDimnames=FALSE))) {
            stop("per-column values are not compatible")
        }
    }
 
    old.validity <- S4Vectors:::disableValidity()
    S4Vectors:::disableValidity(TRUE)
    on.exit(S4Vectors:::disableValidity(old.validity))

    out <- callNextMethod()
    BiocGenerics:::replaceSlots(out, rowVec=all.rv,
        rowToRowMat=all.rrm, colToRowMat=all.crm, 
        check=FALSE)
})
```

We check the other per-column slots across all elements to ensure that they are the same.
This protects the user against combining incompatible objects.
However, depending on the application, this may not be necessary (or too costly) for all slots, in which case it can be limited to critical slots.

We also use the `disableValidity` method to avoid the validity check in the base `cbind` method.
This is because the object is technically invalid when the base slots are combined but before it is updated with the new combined values for the custom slots.
The `on.exit` call ensures that the original validity setting is restored upon exit of the function.

We check that `rbind` does indeed combine by row:

```{r}
(combined <- rbind(thing, thing))
```

... and more formally with `r CRANpkg("testthat")`:

```{r}
rtwice <- rep(seq_len(nrow(thing)), 2)
expect_identical(rowVec(combined), rowVec(thing)[rtwice])
expect_identical(rowToRowMat(combined), rowToRowMat(thing)[rtwice,])
expect_identical(colToRowMat(combined), colToRowMat(thing)[,rtwice])
expect_identical(colVec(combined), colVec(thing)) # columns unaffected...
expect_identical(colToColMat(combined), colToColMat(thing))
expect_identical(rowToColMat(combined), rowToColMat(thing))
```

## By column

We similarly define a `cbind` method to handle the custom slots.

```{r}
#' @export
setMethod("cbind", "ExampleClass", function(..., deparse.level=1) {
    args <- list(...)
    all.cv <- lapply(args, colVec, withDimnames=FALSE)
    all.ccm <- lapply(args, colToColMat, withDimnames=FALSE)
    all.rcm <- lapply(args, rowToColMat, withDimnames=FALSE)

    all.cv <- do.call(c, all.cv)
    all.ccm <- do.call(cbind, all.ccm)
    all.rcm <- do.call(rbind, all.rcm)

    # Checks for identical column state.
    ref <- args[[1]]
    ref.rv <- rowVec(ref, withDimnames=FALSE)
    ref.rrm <- rowToRowMat(ref, withDimnames=FALSE)
    ref.crm <- colToRowMat(ref, withDimnames=FALSE)
    for (x in args[-1]) {
        if (!identical(ref.rv, rowVec(x, withDimnames=FALSE)) 
            || !identical(ref.rrm, rowToRowMat(x, withDimnames=FALSE))
            || !identical(ref.crm, colToRowMat(x, withDimnames=FALSE))) {
            stop("per-row values are not compatible")
        }
    }

    old.validity <- S4Vectors:::disableValidity()
    S4Vectors:::disableValidity(TRUE)
    on.exit(S4Vectors:::disableValidity(old.validity))

    out <- callNextMethod()
    BiocGenerics:::replaceSlots(out, colVec=all.cv,
        colToColMat=all.ccm, rowToColMat=all.rcm, 
        check=FALSE)
})
```

Checking it yields a sensible result:

```{r}
(combined <- cbind(thing, thing))
```

... and testing more formally with `r CRANpkg("testthat")`.
We use `test_equivalent` here for simplicity, as column names are altered to preserve uniqueness.

```{r}
ctwice <- rep(seq_len(ncol(thing)), 2)
expect_equivalent(colVec(combined), colVec(thing)[ctwice]) 
expect_equivalent(colToColMat(combined), colToColMat(thing)[,ctwice])
expect_equivalent(rowToColMat(combined), rowToColMat(thing)[ctwice,])
expect_equivalent(rowVec(combined), rowVec(thing)) # rows unaffected...
expect_equivalent(rowToRowMat(combined), rowToRowMat(thing))
expect_equivalent(colToRowMat(combined), colToRowMat(thing))
```

# Session information

```{r}
sessionInfo()
```
