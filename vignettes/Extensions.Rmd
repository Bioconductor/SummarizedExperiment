---
title: "Extending the SummarizedExperiment class"
author: Aaron Lun
date: "Revised: 28 April, 2018"
output:
  BiocStyle::html_document:
    toc: true
vignette: >
  %\VignetteIndexEntry{Extensions}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r, echo=FALSE, results="hide"}
knitr::opts_chunk$set(error=FALSE, warning=FALSE, message=FALSE)
```

```{r, echo=FALSE}
library(SummarizedExperiment)
```

# Motivation

A large number of Bioconductor packages contain extensions of the standard `SummarizedExperiment` class from the `r Biocpkg("SummarizedExperiment")` package.
This allows developers to take advantage of the power of the `SummarizedExperiment` representation for synchronising data and metadata, 
while still accommodating specialized data structures for particular scientific applications.
This document is intended to provide a developer-level "best practices" reference for the creation of these derived classes.

# Creating a derived class

To demonstrate, we will consider the derivation of an example class that requires some specialized slots.
First, we consider 1D data structures:

- `rowVec`: 1:1 mapping from each value to a row of the `SummarizedExperiment`.
- `colVec`: 1:1 mapping from each value to a column of the `SummarizedExperiment`.

Any 1D structure can be used if it supports `length`, `c`, `[` and `[<-`.
For simplicity, we will use integer vectors for the `*.vec` slots.

We also consider some 2D data structures: 

- `rowToRowMat`: 1:1 mapping from each row to a row of the `SummarizedExperiment`.
- `colToColMat`: 1:1 mapping from each column to a column of the `SummarizedExperiment`.
- `rowToColMat`: 1:1 mapping from each row to a column of the `SummarizedExperiment`.
- `colToRowMat`: 1:1 mapping from each column to a row of the `SummarizedExperiment`.

Any 2D structure can be used if it supports `nrow`, `ncol`, `cbind`, `rbind`, `[` and `[<-`.
For simplicity, we will use (numeric) matrices for the `*.mat` slots.

Definition of the class is achieved using the `setClass` function from the `r CRANpkg("methods")` package, as conventionally done for all S4 classes.

```{r}
.ExampleClass <- setClass("ExampleClass",
    slots= representation(
        rowVec="integer",
        colVec="integer",
        rowToRowMat="matrix",
        colToColMat="matrix",
        rowToColMat="matrix",
        colToRowMat="matrix"
    ),
    contains="SummarizedExperiment")
```

# Defining the constructor

The constructor should provide some arguments for setting the new slots in the derived class definition.
The default values should be set such that calling the constructor without any arguments returns a valid `ExampleClass` object.
We use `...` to pass further arguments to the `SummarizedExperiment` constructor, which allows us to avoid re-specifying all its arguments.
Of course, it is straightforward to specify individual arguments to be passed to the `SummarizedExperiment` constructor if necessary.

```{r}
ExampleClass <- function(
        rowVec=integer(0), 
        colVec=integer(0),
        rowToRowMat=matrix(0,0,0),
        colToColMat=matrix(0,0,0),
        rowToColMat=matrix(0,0,0),
        colToRowMat=matrix(0,0,0),
        ...) {
    
    se <- SummarizedExperiment(...)
    .ExampleClass(se, rowVec=rowVec, colVec=colVec,
        rowToRowMat=rowToRowMat, colToColMat=colToColMat, 
        rowToColMat=rowToColMat, colToRowMat=colToRowMat)
}
```

Let's test out this constructor with an instance of `ExampleClass` that has 10 rows and 7 columns:

```{r}
thing <- ExampleClass(rowVec=1:10, colVec=sample(50, 7),
    rowToRowMat=matrix(runif(30), nrow=10),
    colToColMat=matrix(runif(14), ncol=7),
    rowToColMat=matrix(runif(21), nrow=7),
    colToRowMat=matrix(runif(20), ncol=10),
    assays=list(counts=matrix(rnorm(70), nrow=10)),
    colData=DataFrame(whee=LETTERS[1:7]),
    rowData=DataFrame(yay=letters[1:10]))
```

# Creating getter methods

## For 1D data structures

We define some getter methods for the custom slots containing the 1D structures.
This usually requires the creation of new generics if they are not already available, e.g., in `r Biocpkg("BiocGenerics")` or `r Biocpkg("S4Vectors")`^[If you have an idea for a generally applicable generic that is not yet available, please contact the Bioconductor core team.].
The `...` in the generic function definition means that custom arguments can be provided for specific methods.

```{r}
setGeneric("rowVec", function(x, ...) standardGeneric("rowVec"))
setGeneric("colVec", function(x, ...) standardGeneric("colVec"))
```

We then define the class-specific methods for these generics.
Note the `withDimnames=TRUE` argument, which enforces consistency between the names of the extracted object and the original `SummarizedExperiment`.
It is possible to turn this off for greater efficiency, e.g., for internal usage where names are not necessary.

```{r}
setMethod("rowVec", "ExampleClass", function(x, withDimnames=TRUE) {
    out <- x@rowVec
    if (withDimnames) 
        names(out) <- rownames(x)
    out
})
setMethod("colVec", "ExampleClass", function(x, withDimnames=TRUE) {
    out <- x@colVec
    if (withDimnames) 
        names(out) <- colnames(x)
    out
})
```

We test these methods out:

```{r}
rowVec(thing)
colVec(thing)
```

## For 2D data structures

We repeat this process for the 2D structures.

```{r}
setGeneric("rowToRowMat", function(x, ...) standardGeneric("rowToRowMat"))
setGeneric("colToColMat", function(x, ...) standardGeneric("colToColMat"))
setGeneric("rowToColMat", function(x, ...) standardGeneric("rowToColMat"))
setGeneric("colToRowMat", function(x, ...) standardGeneric("colToRowMat"))
```

Again, we define class-specific methods for these generics.

```{r}
setMethod("rowToRowMat", "ExampleClass", function(x, withDimnames=TRUE) {
    out <- x@rowToRowMat
    if (withDimnames) 
        rownames(out) <- rownames(x)
    out
})
setMethod("colToColMat", "ExampleClass", function(x, withDimnames=TRUE) {
    out <- x@colToColMat
    if (withDimnames) 
        colnames(out) <- colnames(x)
    out
})
setMethod("rowToColMat", "ExampleClass", function(x, withDimnames=TRUE) {
    out <- x@rowToColMat
    if (withDimnames) 
        rownames(out) <- colnames(x)
    out
})
setMethod("colToRowMat", "ExampleClass", function(x, withDimnames=TRUE) {
    out <- x@colToRowMat
    if (withDimnames) 
        colnames(out) <- rownames(x)
    out
})
```

Testing them out:

```{r}
dim(rowToRowMat(thing))
dim(colToColMat(thing))
dim(rowToColMat(thing))
dim(colToRowMat(thing))
```

## For `SummarizedExperiment` slots

Obviously, we can use the getter methods defined in `r Biocpkg("SummarizedExperiment")` to retrieve data from slots in the base class:

```{r}
assayNames(thing)
colData(thing)
rowData(thing)
```

These should generally not require any re-defining for a derived class.
However, if it is necessary, the methods should use `callNextMethod` internally.
This will call the method for the base `SummarizedExperiment` class, the output of which can be modified as required.

```{r}
setMethod("rowData", "ExampleClass", function(x, ...) {
    out <- callNextMethod()
    # Do something extra here.
    out
})
```

# Defining the validity method

We want to be notified (and an error to be thrown) if the new slots are filled with inappropriate values.
This is done by defining a validity function using `setValidity2` from the `r Biocpkg("S4Vectors")` package^[This allows us to turn off the validity checks in internal functions where intermediate objects may not be valid within the scope of the function.].
Returning a string indicates that there is a problem with the validity of the `ExampleClass` instance.

```{r}
setValidity2("ExampleClass", function(object) {
    NR <- NROW(object)
    NC <- NCOL(object)
    msg <- NULL

    # 1D
    print(c(NR, NC))
    if (length(rowVec(object, withDimnames=FALSE)) != NR) {
        msg <- c(msg, "'rowVec' should have length equal to the number of rows")
    }
    if (length(colVec(object, withDimnames=FALSE)) != NC) {
        msg <- c(msg, "'colVec' should have length equal to the number of columns")
    }

    # 2D
    if (NROW(rowToRowMat(object, withDimnames=FALSE)) != NR) {
        msg <- c(msg, "'nrow(rowToRowMat)' should be equal to the number of rows")
    }
    if (NCOL(colToColMat(object, withDimnames=FALSE)) != NC) {
        msg <- c(msg, "'ncol(colToColMat)' should be equal to the number of columns")
    }
    if (NROW(rowToColMat(object, withDimnames=FALSE)) != NC) {
        msg <- c(msg, "'nrow(rowToColMat)' should be equal to the number of columns")
    }
    if (NCOL(colToRowMat(object, withDimnames=FALSE)) != NR) {
        msg <- c(msg, "'ncol(colToRowMat)' should be equal to the number of rows")
    }

    if (length(msg)) {
        return(msg)
    }
    return(TRUE)
})
```

Some notes about this function:

- We use the `NCOL` and `NROW` methods from `r Biocpkg("BiocGenerics")` as these provide support for various Bioconductor objects.
- We use the getter functions to retreive the slot values rather than using `@`.
There were good reasons for this, but I have forgotten them.
- We also set `withDimnames=FALSE` in our getter calls, as consistent naming is not necessary for internal functions.

# Creating a `show` method

The default `show` method will only display the `SummarizedExperiment` slots.
We can augment it to display some relevant aspects of the custom slots.
This is done by calling the base `show` method before printing additional fields as necessary.

```{r}
setMethod("show", "ExampleClass", function(object) {
    callNextMethod()
    cat(
        "rowToRowMat has ", ncol(rowToRowMat(object)), " columns\n",
        "colToColMat has ", nrow(colToColMat(object)), " rows\n",
        "rowToColMat has ", ncol(rowToRowMat(object)), " columns\n",
        "colToRowMat has ", ncol(rowToRowMat(object)), " rows\n",
        sep=""
    )
})
```

Printing the object will now add the extra information about the custom slots.

```{r}
thing
```

# Creating setter methods

## For 1D data structures

We define some setter methods for the custom slots containing the 1D structures.
Again, this usually requires the creation of new generics.

```{r}
setGeneric("rowVec<-", function(x, ..., value) standardGeneric("rowVec<-"))
setGeneric("colVec<-", function(x, ..., value) standardGeneric("colVec<-"))
```

We define the class-specific methods for these generics.
Note that use of `validObject` to ensure that the assigned input is still valid.

```{r}
setReplaceMethod("rowVec", "ExampleClass", function(x, value) {
    x@rowVec <- value
    validObject(x)
    x
})
setReplaceMethod("colVec", "ExampleClass", function(x, value) {
    x@colVec <- value
    validObject(x)
    x
})
```

We test these methods out:

```{r}
rowVec(thing) <- 0:9
rowVec(thing)
colVec(thing) <- 7:1
colVec(thing)
```

## For 2D data structures

We repeat this process for the 2D structures.

```{r}
setGeneric("rowToRowMat<-", function(x, ..., value) standardGeneric("rowToRowMat<-"))
setGeneric("colToColMat<-", function(x, ..., value) standardGeneric("colToColMat<-"))
setGeneric("rowToColMat<-", function(x, ..., value) standardGeneric("rowToColMat<-"))
setGeneric("colToRowMat<-", function(x, ..., value) standardGeneric("colToRowMat<-"))
```

Again, we define class-specific methods for these generics.

```{r}
setReplaceMethod("rowToRowMat", "ExampleClass", function(x, value) {
    x@rowToRowMat <- value
    validObject(x)
    x
})
setReplaceMethod("colToColMat", "ExampleClass", function(x, value) {
    x@colToColMat <- value
    validObject(x)
    x
})
setReplaceMethod("rowToColMat", "ExampleClass", function(x, value) {
    x@rowToColMat <- value
    validObject(x)
    x
})
setReplaceMethod("colToRowMat", "ExampleClass", function(x, value) {
    x@colToRowMat <- value
    validObject(x)
    x
})
```

Testing them out:

```{r}
rowToRowMat(thing) <- -rowToRowMat(thing)
colToColMat(thing) <- -colToColMat(thing)
rowToColMat(thing) <- -rowToColMat(thing)
colToRowMat(thing) <- -colToRowMat(thing)
```

## For `SummarizedExperiment` slots

Again, we can use the setter methods defined in `r Biocpkg("SummarizedExperiment")` to modify slots in the base class:

```{r}
colData(thing)$stuff <- sample(100, ncol(thing))
rowData(thing)$blah <- sample(100, nrow(thing))
```

These should generally not require any re-defining.
However, if it is necessary, the methods should use `callNextMethod` internally:

```{r}
setReplaceMethod("rowData", "ExampleClass", function(x, ..., value) {
    y <- callNextMethod() # returns a modified ExampleClass
    # Do something extra here.
    return(y)
})
```

## Other types of modifying functions 

Imagine that we want to write a function that returns a modified `ExampleClass`, e.g., where the signs of the `*.vec` fields are reversed.
For example, we will pretend that we want to write a `normalize` function, using the generic from `r Biocpkg("BiocGenerics")`.

```{r}
setMethod("normalize", "ExampleClass", function(object) {
    # do something exciting, i.e., flip the signs
    new.row <- -rowVec(object, withDimnames=FALSE) 
    new.col <- -colVec(object, withDimnames=FALSE)
    BiocGenerics:::replaceSlots(object, rowVec=new.row, 
        colVec=new.col, check=FALSE)
})
```

We use `BiocGenerics:::replaceSlots` instead of the setter methods that we defined above.
This is because our setters perform validity checks that are unnecessary if we know that the modification cannot alter the validity of the object.
The `replaceSlots` function allows us to skip these validity checks for greater efficiency.

```{r}
modified <- normalize(thing)
rowVec(modified)
colVec(modified)
```

# Enabling subsetting operations

## Getting a subset

A key strength of the `SummarizedExperiment` class is that subsetting is synchronized across the various (meta)data fields.
This avoids book-keeping errors and guarantees consistency throughout an interactive analysis session.
We need to ensure that the values in our custom slots are also subsetted.

```{r}
setMethod("[", "ExampleClass", function(x, i, j, drop=TRUE) {
    rv <- rowVec(x, withDimnames=FALSE)
    cv <- colVec(x, withDimnames=FALSE)
    rrm <- rowToRowMat(x, withDimnames=FALSE)
    ccm <- colToColMat(x, withDimnames=FALSE)
    rcm <- rowToColMat(x, withDimnames=FALSE)
    crm <- colToRowMat(x, withDimnames=FALSE)

    if (!missing(i)) {
        if (is.character(i)) {
            fmt <- paste0("<", class(x), ">[i,] index out of bounds: %s")
            i <- SummarizedExperiment:::.SummarizedExperiment.charbound(i, rownames(x), fmt)
        }
        i <- as.vector(i)
        rv <- rv[i]
        rrm <- rrm[i,,drop=FALSE]
        crm <- crm[,i,drop=FALSE]
    }

    if (!missing(j)) {
        if (is.character(j)) {
            fmt <- paste0("<", class(x), ">[,j] index out of bounds: %s")
            j <- SummarizedExperiment:::.SummarizedExperiment.charbound(j, colnames(x), fmt)
        }
        j <- as.vector(j)
        cv <- cv[j]
        ccm <- ccm[,j,drop=FALSE]
        rcm <- rcm[j,,drop=FALSE]
    }

    out <- callNextMethod()
    BiocGenerics:::replaceSlots(out, rowVec=rv, colVec=cv,
        rowToRowMat=rrm, colToColMat=ccm, 
        rowToColMat=rcm, colToRowMat=crm, check=FALSE)
})
```

Note the special code for handling character indices, and the use of `callNextMethod` to subset the base `SummarizedExperiment` slots.

We can check that this is working properly:

```{r}
thing[1:5,]
thing[,1:2]
```

## Assigning a subset

Subset assignment can be similarly performed, though the signature needs to be specified so that the replacement value is of the same class.
This is generally necessary for sensible replacement of the custom slots.

```{r}
setReplaceMethod("[", c("ExampleClass", "ANY", "ANY", "ExampleClass"),
        function(x, i, j, ..., value) {
    rv <- rowVec(x, withDimnames=FALSE)
    cv <- colVec(x, withDimnames=FALSE)
    rrm <- rowToRowMat(x, withDimnames=FALSE)
    ccm <- colToColMat(x, withDimnames=FALSE)
    rcm <- rowToColMat(x, withDimnames=FALSE)
    crm <- colToRowMat(x, withDimnames=FALSE)

    if (!missing(i)) {
        if (is.character(i)) {
            fmt <- paste0("<", class(x), ">[i,] index out of bounds: %s")
            i <- SummarizedExperiment:::.SummarizedExperiment.charbound(i, rownames(x), fmt)
        }
        i <- as.vector(i)
        rv[i] <- rowVec(value, withDimnames=FALSE)
        rrm[i,] <- rowToRowMat(value, withDimnames=FALSE)
        crm[,i] <- colToRowMat(value, withDimnames=FALSE)
    }

    if (!missing(j)) {
        if (is.character(j)) {
            fmt <- paste0("<", class(x), ">[,j] index out of bounds: %s")
            j <- SummarizedExperiment:::.SummarizedExperiment.charbound(j, colnames(x), fmt)
        }
        j <- as.vector(j)
        cv[j] <- colVec(value, withDimnames=FALSE)
        ccm[,j] <- colToColMat(value, withDimnames=FALSE)
        rcm[j,] <- rowToColMat(value, withDimnames=FALSE)
    }

    out <- callNextMethod()
    BiocGenerics:::replaceSlots(out, rowVec=rv, colVec=cv,
        rowToRowMat=rrm, colToColMat=ccm, 
        rowToColMat=rcm, colToRowMat=crm, check=FALSE)
})
```

We can check that this is working properly:

```{r}
modified <- thing
modified[1:5,] <- thing[5:1,]
modified[,1:2] <- thing[,2:1]
rowVec(modified)
colVec(modified)
````

# Defining combining methods

## By row

We need to define a `rbind` method for our custom class.
This is done by combining the custom per-row slots across class instances.

```{r}
setMethod("rbind", "ExampleClass", function(..., deparse.level=1) {
    args <- list(...)
    all.rv <- lapply(args, rowVec, withDimnames=FALSE)
    all.rrm <- lapply(args, rowToRowMat, withDimnames=FALSE)
    all.crm <- lapply(args, colToRowMat, withDimnames=FALSE)

    all.rv <- do.call(c, all.rv)
    all.rrm <- do.call(rbind, all.rrm)
    all.crm <- do.call(cbind, all.crm)

    # Checks for identical column state.
    ref <- args[[1]]
    ref.cv <- colVec(ref, withDimnames=FALSE)
    ref.ccm <- colToColMat(ref, withDimnames=FALSE)
    ref.rcm <- rowToColMat(ref, withDimnames=FALSE)
    for (x in args[-1]) {
        if (!identical(ref.cv, colVec(x, withDimnames=FALSE)) 
            || !identical(ref.ccm, colToColMat(x, withDimnames=FALSE))
            || !identical(ref.rcm, rowToColMat(x, withDimnames=FALSE))) {
            stop("per-column values are not compatible")
        }
    }
 
    old.validity <- S4Vectors:::disableValidity()
    S4Vectors:::disableValidity(TRUE)
    on.exit(S4Vectors:::disableValidity(old.validity))

    out <- callNextMethod()
    BiocGenerics:::replaceSlots(out, rowVec=all.rv,
        rowToRowMat=all.rrm, colToRowMat=all.crm, 
        check=FALSE)
})
```

We check the other per-column slots across all elements to ensure that they are the same.
This protects the user against combining incompatible objects.
However, depending on the application, this may not be necessary (or too costly) for all slots, in which case it can be limited to critical slots.

We also use the `disableValidity` method to avoid the validity check in the base `cbind` method.
This is because the object is technically invalid when the base slots are combined but before it is updated with the new combined values for the custom slots.
The `on.exit` call ensuress that the original validity setting is restored upon exit of the function.

Testing yields something sensible:

```{r}
rbind(thing, thing)
```

## By column

We similarly define a `cbind` method to handle the custom slots.

```{r}
setMethod("cbind", "ExampleClass", function(..., deparse.level=1) {
    args <- list(...)
    all.cv <- lapply(args, colVec, withDimnames=FALSE)
    all.ccm <- lapply(args, colToColMat, withDimnames=FALSE)
    all.rcm <- lapply(args, rowToColMat, withDimnames=FALSE)

    all.cv <- do.call(c, all.cv)
    all.ccm <- do.call(cbind, all.ccm)
    all.rcm <- do.call(rbind, all.rcm)

    # Checks for identical column state.
    ref <- args[[1]]
    ref.rv <- rowVec(ref, withDimnames=FALSE)
    ref.rrm <- rowToRowMat(ref, withDimnames=FALSE)
    ref.crm <- colToRowMat(ref, withDimnames=FALSE)
    for (x in args[-1]) {
        if (!identical(ref.rv, rowVec(x, withDimnames=FALSE)) 
            || !identical(ref.rrm, rowToRowMat(x, withDimnames=FALSE))
            || !identical(ref.crm, colToRowMat(x, withDimnames=FALSE))) {
            stop("per-row values are not compatible")
        }
    }

    old.validity <- S4Vectors:::disableValidity()
    S4Vectors:::disableValidity(TRUE)
    on.exit(S4Vectors:::disableValidity(old.validity))

    out <- callNextMethod()
    BiocGenerics:::replaceSlots(out, colVec=all.cv,
        colToColMat=all.ccm, rowToColMat=all.rcm, 
        check=FALSE)
})
```

And testing seems to yield a sensible outcome:

```{r}
cbind(thing, thing)
```

# Session information

```{r}
sessionInfo()
```
